import fs from "fs/promises";
import path from "path";

import { codegenForTs, codegenForDoc } from "../../codegen-lib/index.js";
import { logger } from "../../logging/index.js";
import { getAllCogenieSteps } from "./getAllCogenieSteps.js";
import { getGeneratedFilesDirent } from "./getGeneratedFilesDirent.js";

/**
 * Delete all stale generated files that are generated by cogenie steps.
 *
 * ## What is a stale generated file?
 * If the output file(s) of a cogenie step changes, e.g. the output file is
 * renamed, during the next run the originally generated file will still be
 * there and the new one will also appear. But since the old file is no longer
 * used it is considered to be a "stale file" in our version control.
 *
 * ## How?
 * This function will find all new output files of all cogenie steps, and look
 * for existing generated files that is not in this set of expected output files
 * and delete them.
 */
export async function deleteStaleGeneratedFiles() {
  const cogenieSteps = await getAllCogenieSteps().then((CogenieSteps) =>
    CogenieSteps.map((CogenieStep) => new CogenieStep()),
  );

  const cogenieStepsGeneratedFileTargets = cogenieSteps
    .map((cogenieStep) => Object.values(cogenieStep.getFiles()))
    .flat()
    .map((fileTarget) => fileTarget.name + fileTarget.extension);

  const cogenieStepsGeneratedFileTargetsSet = new Set(
    cogenieStepsGeneratedFileTargets,
  )
    // Add in the special case generated barrel file
    .add("index.ts");

  const generatedFilesDirent = await getGeneratedFilesDirent();

  // Map generated files to include a "shortName", the same that is used as the
  // key in the generated file targets set
  const generatedFilesWithShortName = generatedFilesDirent.map((file) => {
    let fileShortName: string;

    if (file.name.endsWith(codegenForTs.generatedCodeFileExtension)) {
      fileShortName = file.name.replace(
        codegenForTs.generatedCodeFileExtension,
        ".ts",
      );
    } else if (
      file.name.endsWith(
        codegenForTs.generatedCodeFileExtensionWithNoBarrelFileInclusion,
      )
    ) {
      fileShortName = file.name.replace(
        codegenForTs.generatedCodeFileExtensionWithNoBarrelFileInclusion,
        ".ts",
      );
    } else if (file.name.endsWith(codegenForDoc.generatedDocFileExtension)) {
      fileShortName = file.name.replace(
        codegenForDoc.generatedDocFileExtension,
        ".md",
      );
    }
    // In the special case where there is no ".generated" extension in the file
    // extension, yet still returned by "getGeneratedFilesDirent", treat the
    // name itself as the short name without any other modification
    else if (file.name.endsWith(".ts") || file.name.endsWith(".md")) {
      fileShortName = file.name;
    } else {
      throw new Error("Not possible since files filtered above");
    }

    return {
      parentPath: file.parentPath,
      name: file.name,
      shortName: fileShortName,
    };
  });

  // Get list of files that are no longer a part of the generated file targets
  // set for deletion
  const generatedFilesToDelete = generatedFilesWithShortName.filter(
    (file) => !cogenieStepsGeneratedFileTargetsSet.has(file.shortName),
  );

  // Delete the file and map back the promise to await together later
  const generatedFilesDeletionPromises = generatedFilesToDelete.map(
    async (file) => {
      const fullFilePath = path.resolve(file.parentPath, file.name);
      await fs.rm(fullFilePath);
      return fullFilePath;
    },
  );

  // Wait for all files to be deleted
  const deletedFiles = await Promise.all(generatedFilesDeletionPromises);

  if (deletedFiles.length > 0) {
    logger.info(
      deleteStaleGeneratedFiles.name,
      `Deleted ${deletedFiles.length} generated files:`,
    );
    for (const file of deletedFiles) {
      logger.info(deleteStaleGeneratedFiles.name, file);
    }
  } else {
    logger.info(
      deleteStaleGeneratedFiles.name,
      "No generated files deleted but some may still be overwritten",
    );
  }
}
